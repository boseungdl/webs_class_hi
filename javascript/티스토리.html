<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    console을 쓰는이유
1. dom, defer, async
2. var let const 차이
(var 호이스팅가능)변수와 상수
해커들이 코드를 변경하는 걸 방지한다 const
-security
-thread safety 갑을 동시변경 위험
-reduce human mistake 코드 변경시 실수 방지한다
3. variable types
number
string
boolean
null 너는 텅빈값이야
undefined 선언은 됐지만 할당x
symbol
4. 연산자
함수호출시 제일 뒤로
ex(or: value1 || valaue2 || function)
5.function
반복되는 일
이것은 함수입니다(function) 함수이름(코드와 관련있는) {함수의 내용}


함수는 값을 받아 이 함수 안에서  매개변수를 이용한 식(오브젝트든 머든)을 만들어 리턴값으로 출력해준다.

함수 선언
function이라는 키워드와 원하는 함수이름을 정의하고 ()안에는 어떤값을 전달받아 올건지(전달받는 인자를 정의)
{}안에는 실제로 함수 안에서 어떤 코드가 동작하는지
함수도 오브젝트랑 똑같다 함수이름은 함수자체를 저장하지 않고 함수가 정의된 곳의 주소를 저장한다(reference)
어떤 변수에 함수를 할당하면 함수를 가르키는 주소가 할당이 된다. 결국 변수와 함수는 같다
함수의 인자(매개변수)를 적을 때는 함수의 내용과 관련된 의미있는 이름을 지어준다

함수 이것은 함수입니다.
함수이름 가능한 의미 있는 이름(어떤 기능인지)
()안에 들어가는 인자들이 값을 받아옴(기능을 이루는 각각의 것과 관련된)-변수와 마찬가지로 인자 하나당 메모리공간이
하나씩 생긴다(함수를 만든시점에는 메모리가 비어있다.)
코드블록 = 기능



function(a,b) {
    const sum = a+b;
}

함수 호출
함수이름();

함수 타입
어떤 기능을 수행
또는 어떤 값을 받아와 어떤 변수에 접근해 
계산을 한다음 특정한 값을 전달


api?
조건이 아닐때 빨리 리턴해서 함수 종료하고 맞을때만 필요한 로직을 실행
해야 가독성도 좋고 그렇다
익명함수란 함수의 이름이 없는거
콜백함수
function func(answer, printyes, printno)
매개변수인 answer에 대답이 맞으면ㅡ 프린트예스 함수 출력 아니면 no



6.클래스와 오브젝트
클래스는 틀(오브젝트를 이루는 속성, 메서드, 등을 모아놓음) 오브젝트는 틀을이용해서 만들어진거
7.오브젝트
obg.key와obg[key]
8.배열
비슷한 종료에 데이터를 모아놓는 것 = 자료구조 


9.변수
숫자면 num age 등등의 관련 이름으로 변수이름 짓기 어떤 정보를 갖고있는지 유추하기 쉽다
변수를 선언하면 그 변수만의 메모리 공간이 생긴다. 
가장작은 데이터 타입(primitive 타입) = 숫자 스트링 불린 null undefined symbol 
// 이런 데이터 타입을 제외한 모두가 object(최소한 한두가지의 다양한 데이터를 한군데에다 묶어 놓은 아이)(배열, 리스트 함수..)
let obg - {}; obg라는 변수에는 123이 들어가있다 오브젝트는 너무커 변수에 들어가기엔 너무 크다 오브젝트는 각각 키마다 
공간이 할당이 된다. 그것들을 묶은 주소(reference)가 있는데 그 주소만 obg라는 변수에 할당이된다.
상수변수(const)를 쓰는 obg는 obg 자체가 담겨있는게 아니라 obg를 가리키는 reference가 담겨있기 때문에 reference는
다른 obg로 변경 불가능하지만reference가 가리키는 obg의 안의 내용은 변경이 가능하다.










<h3>window 객체</h3>
<p>1. 브라우저 안의 모든 요소들이 소속된 객체로, 최상위에 있기 때문에 어디서든 접근이 가능하다고 해서 
    '전역 객체'라고도 부른다.<br> 2. 일반적으로 우리가 열고 있는 브라우저의 창(browser window)을 의미하고, 
    창 열기, 창 닫기, 창 크기 조절 등 창을 제어하는 다양한 작업을 할 수 있다.
</p>


<h3>브라우저 객체 모델BOM (Browser Object Model)</h3>
    <p>브라우저 객체 모델이란, 말 그대로 브라우저에 대한 모든 내용을 담고있는 객체이다.
        브라우저에 관한 정보를 제공하거나 브라우저의 모양을 제어하도록 제공되는 객체들이다.   
        대표적으로 아래와 같은 객체들이 존재한다.</p>

        <h4>window 객체</h4>
        <p> 인터넷 브라우저를 보면 위에 탭들도 있고, 주소창도 있고, 즐겨찾기 그리고 툴바들도 있을 수 있고요. 그 다음부터는 이제 웹사이트가 표시됩니다. 여기서 브라우저 전체를 담당하는 게 Window 객체이고, 웹사이트만 담당하는게 Document 객체라고 이해하시면 됩니다. Document도 Window 객체 안에 들어있습니다.
            window는 모든 객체의 조상입니다. 전역객체(글로벌객체)라고 하는데요. 모든 객체를 다 포함하고 있기 때문에 window는 그냥 생략가능합니다.</p>
        
        <h4>location 객체</h4>
        <p>현재 웹 브라우저가 보고 있는 위치(페이지)에 관한 객체  location.reload()로 새로고침도 가능합니다.
             location.replace()는 현재 주소를 다른 주소로 교체합니다. (다른 페이지로 이동하지만 이전 페이지 기록이 남지 않습니다)
        </p>

        <h4>navigator 객체</h4>
        <p>navigator 객체는 브라우저 공급자 및 버전 정보 등을 포함한 브라우저에 대한 다양한 정보를 저장하는 객체입니다.</p>

        <h4>Screen 객체</h4>
        <p>screen 객체는 사용자의 디스플레이 화면에 대한 다양한 정보를 저장하는 객체입니다.
            너비(width), 높이(height), 픽셀(pixelDepth), 컬러(colorDepth), 화면 방향(orientation)
            , 작업표시줄을 제외한 너비와 높이(availWidth, availHeight) 등이 있습니다.</p>

        <h4>history 객체</h4>
        <p>웹 브라우저의 페이지 이동 내역을 담고 있는 객체
            히스토리간에 이동(history.go(페이지수))할 수도 있습니다. history.length는 뒤로가기할 수 있는 페이지의 개수를 의미합니다.
        </p>



  
</body>
  
<h3>position 속성</h3>
<p>CSS에서 position 속성은 HTML 문서 상에서 요소가 배치되는 방식을 결정합니다. 많은 경우, position 속성은 요소의 정확한 위치 지정을 위해서 top, left, bottom, right 속성과 함께 사용됩니다.</p>

<h4>position: static</h4>
<p>position 속성을 별도로 지정해주지 않으면 기본값인 static이 적용됩니다. position 속성이 static인 요소는 HTML 문서 상에서 원래 있어야하는 위치에 배치됩니다.
     이 말은 요소들이 HTML에 작성된 순서 그대로 브라우저 화면에 표시가 된다는 것을 뜻하며, 따라서 top, left, bottom, right 속성값은 position 속성이 static일 때는 무시됩니다.</p>
<h4>position: relative</h4>
<p>position 속성을 relative로 설정하게 되면, 요소를 원래 위치에서 벗어나게 배치할 수 있게 됩니다. 요소를 원래 위치를 기준으로 상대적(relative)으로 배치해준다고 생각하시면 이해가 쉬울 것 같은데요. 요소의 위치 지정은 top, bottom, left, right 속성을 이용해서, 요소가 원래 위치에 있을 때의 상하좌우로 부터 얼마나 떨어지게 할지를 지정할 수 있습니다.</p>
<h4>position: absolute</h4>
<p>배치 기준을 자신이 아닌 상위 요소에서 찾습니다. DOM 트리를 따라 올라가다가 position 속성이 static이 아닌 첫 번째 상위 요소가 해당 요소의 배치 기준으로 설정되는데요. 만약에 해당 요소 상위에 position 속성이 static이 아닌 요소가 없다면, DOM 트리에 최상위에 있는 &lt;body&gt; 요소가 배치 기준이 됩니다.  대부분의 경우, 부모 요소(가장 가까운 상위 요소)를
     기준으로 top, left, bottom, right 속성을 적용해야하기 때문입니다. 따라서 어떤 요소의 display 속성을 absolute로 설정하면, 부모 요소의 display 속성을 relative로 지정해주는 것이 관례입니다. 또한 position: absolute인 요소는 HTML 문서 상에서 독립되어 앞뒤에 나온 요소와 더 이상 상호작용을 하지 않게 된다는 것입니다. 
    그렇기 때문에 원래있던 자리는 빈자리가 되는 것입니다.</p>
<h4>position: fixed</h4>
<p>화면을 위아래로 스크롤하더라도 브라우저 화면의 특정 부분에 고정되어 움직이지 않는 UI를 본적이 있으신가요? 보통 라이브 채팅 버튼을 구현할 때 많이 쓰이는 기법인데요. position 속성을 fixed로 지정하면 이렇게 요소를 항상 고정된(fixed) 위치에 배치할 수 있습니다.

    이게 가능한 이유는 fixed 속성값의 배치 기준이 자신이나 부모 요소가 아닌 뷰포트(viewport), 즉 브라우저 전체화면이기 때문인데요. top, left, bottom, right 속성은 각각 브라우저 상단, 좌측, 하단, 우측으로 부터 해당 요소가 얼마나 떨어져있는지를 결정합니다.</p>
<h4></h4>
<p></p>
<h4></h4>
<p></p>

<h3>이미지 스프라이트의 정의</h3>
<p>여러 개의 이미지를 하나의 이미지로 만들어 놓은 것을 의미합니다.</p>

<h3>특징</h3>

<h4>1. 요청을 단 한번 만한다.</h4>
<p> 브라우저는 화면을 그릴 때 필요한 모든 자원(이미지, CSS, JS 등)을 서버에 요청하고 가져와 사용합니다. 서버에 요청하고 가져오는 작업은 일괄적으로 한 번에 이루어지지 않습니다. 서버에 자원을 요청하는 구문이 사용된 횟수만큼 서버에 자원을 요청합니다.
    예를 들어 위와 같은 예제는 서버에서 이미지를 가져오기 위해 서버에 3번의 요청을 합니다. 즉 자원을 사용하는 구문 하나는 서버 요청 하나입니다. 예제 코드는 3번의 이미지 요청을 이야기했지만, 가져와야 하는 이미지가 10개 혹은 그 이상이 되면 서버에 이미지를 요청하기 위해서 많은 브라우저 자원을 사용해야 합니다. 이는 결국 화면을 그리는 속도를 저해합니다.
    그렇기 때문에 하나의 이미지에 여러 개의 이미지를 합쳐서 사용하는 이미지 스프라이트를 사용하면, 서버에 이미지를 요청하는 횟수를 한 번으로 줄 일수 있습니다. 거기에 CSS를 사용하면 이미지 스프라이트(여러 개의 이미지가 하나로 합쳐진 이미지)를 하나의 이미지처럼 보이게 할 수 있습니다. 즉 이미지 스프라이트를 잘 활용한다면, 서버에 이미지 요청하는 횟수를 줄이고 화면을 빠르게 그릴 수 있습니다.
</p>

<h4>2. 하나의 이미지 파일만 관리한다.</h4>
<p> 이미지 스프라이트는 여러 개의 이미지를 하나로 합쳤기 때문에, 합친 이미지의 개수만큼 관리를 해야 하는 이미지 파일이 줄어듭니다. 관리해야 하는 이미지 수가 줄어든다는 것은 관리하는 대상이 줄어든다는 말과 같기 때문에 유지보수 측면에서도 유리한 점이 있습니다.
    다만 스프라이트 이미지를 만드는 경우는 아이콘들처럼 문맥적으로 같은 유형을 묶어서 사용하는 것이 좋습니다. 아무리 하나의 이미지라도 다른 의미를 지닌 이미지를 합친다면, 하나의 이미지를 관리하는 게 아니라 여러 개의 이미지를 하나의 파일에서 관리하는 것 일 뿐입니다.
   </p>

<h4>1. 이미지 스프라이트로 만드는 아이콘</h4>
<p></p>
<h4>2. 역동적인 이미지 스프라이트 사용법</h4>
<p></p>
   
<h3>ir기법(Image Replacement)</h3>
<p>- IR 기법은 이미지의 대체텍스트를 제공하기 위한 CSS 기법으로 아래와 같이 다양한 CSS 기법을 사용하여 이미지의 대체 텍스트를 제공할 수 있습니다. </p>

<h3>IR 기법(Image Replacement)의 종류</h3>
<h4>Phark Method</h4>
<p>- 의미있는 이미지의 대체 텍스트를 제공하는 경우에 사용합니다.
    - 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로 (-9999px만큼 내어 쓰기) 빼내어 보이지 않게 하는 방법입니다. </p>
<h4>WA IR</h4>
<p>- 의미있는 이미지의 대체 텍스트로 이미지가 없어도 대체 텍스트를 보여주고자 할 때 사용합니다.
    - 이미지로 대체 할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 화면에 보이지 않게 처리합니다.</p>
<h4>Screen out</h4>
<p>대체 텍스트가 아닌 접근성을 위한 숨김 텍스트를 제공할 때 사용합니다.</p>
https://xxoyeong.tistory.com/81
https://velog.io/@71summernight/Semantic-Web-Semantic-Tag-aidm2h5f
https://designer-ej.tistory.com/entry/CSS-background-%EC%86%8D%EC%84%B1-%EC%A0%95%EB%A6%ACcolor-image-position-repeat-%EB%93%B1
https://sohyunsaurus.tistory.com/57


<h3>콜백함수란?</h3>
<p>콜백함수는 간단하게 다른 함수에 매개변수로 넘겨준 함수를 말한다. 매개변수로 넘겨받은 함수는 일단 넘겨받고, 때가 되면 나중에 호출(called back)한다는 것이 콜백함수의 개념이다.</p>

<p>예를 들자면 이런 것이다.
    코드를 살펴보면 checkGang, linkGang, goodGang 총 3가지 함수를 선언하고checkGang 함수를 호출할 때 매개변수로 count에 숫자값을,그리고 link와 good에 각각 linkGang과 goodGang함수를 전달했다.여기서 linkGang함수와 goodGang함수가 콜백함수 인 것이다.
     checkGang함수가 먼저 호출되고, 매개변수로 들어온 count의 값에 따라 linkGang과 goodGang함수 둘 중 한 가지가 나중에 호출된다.</p>
<p>위 코드는 count가 2이기 때문에 linkGang이 실행된다.</p>

<h3>콜백함수가 필요한 이유</h3>
<p>간단하게 말하면 여러 함수들을 선언하고, 어느 한 함수가 실행될 때,
    상황에 따라 필요한 다른 함수를 실행하고 싶을 때 활용할 수 있다.</p><br>
<p>콜백함수는 때로는 그냥 가독성이나 코드 재사용성 면에서도 활용한다.</p>   

<h3>메서드(method)란?</h3>
<p>어떤 객체가 가지고 있는 어떤 동작을 말한다. 일반적으로 자바스크립트에서는 일반적으로 객체 안에 프로퍼티로 정의된 함수를 메서드라고 부른다.</p>

<h3>this란?</h3>
<p>결국 이 this는 함수에서 나타나는데, this키워드를 사용하면 그 함수를 호출한 주체(객체)를 가리키게 된다.
쉽게 말해서 '누가 이 함수를 불렀느냐'가 된다.</p>

<p>위 코드를 살펴보면, this를 콘솔에 출력하는 printThis라는 함수가 두 개 선언되어 있다. 첫 번째는 myObject의 메서드로 선언되어있고 두 번째는 그냥 일반 함수인데, 아랫부분에 두 함수를 실행한 결과를 살펴보면, 메서드로 실행된 함수의 this는 해당 함수를 호출한 주체, 즉 myObject 객체가 출력되고, 두 번째의 경우에는 window 객체가 출력이 되었다.</p>

<h3>this의 활용</h3>
<p>this는 이렇게 메서드로 활용될 때, 해당 객체의 프로퍼티들을 다양하게 활용할 수 있도록 해준다.</p>



온라인 강의 팁
얻고자 하는 기술 그 기술로 무엇을 할지 목표 설정

html
valuedate??에서 에러 확인 가능
상자로 나누기
article 반복적으로 사용할 시
box(사용자에게 보여지지 않는다.)
item(사용자에게 보여짐) -- block inline level

position
relitive 원래 있었던 자리에서 이동
absolute 담겨 있는 상자에서 이동
fixed 윈도우에서 이동
sticky 원래 자리 그대로지만 스크롤해도 그대로
 
flex box
중심축 반대축

div.container>div.item.item${$}*10
p>lorem3

뷰포인트등
모바일 
링크
애니메이션



<h3>반응형 웹</h3>
<p>반응형 웹은 하나의 웹사이트에서 PC, 스마트폰, 태블릿  PC등 접속하는 디스플레이 종류에 따라서 화면 크기가 자동으로 변하게 해준다. 미디어 쿼리(Media Query)는 접속하는 장치에 따라서 CSS 스타일을 변경한다.( 다른 프로그래밍 언어의 if 조건문과 비슷한 개념)
  PC로 접속하면 PC화면에 맞게, 스마트폰으로 접속하면 스마트폰 화면에 맞게 레이아웃을 변경한다.</p>

<p>뷰 포트(View Port)는 작은 화면의 스마트폰에서 PC의 웹 페이지 표시할 때 전체적인 페이지의 배율을 조정해준다.</p>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
뷰 포트 설정
width=device-width : 페이지의 가로 길이를 기기의 스크린 가로 길이로 설정한다.
height=device-height : 페이지의 세로 길이를 기기의 스크린 세로 길이로 설정한다.
initial-scale : 페이지 로드 시 줌 레벨을 조정한다.
minimum-scale : 줄일 수 있는 최소 크기를 지정한다. (기본값 = 0.25)
maximum-scale : 늘릴 수 있는 최대 크기를 지정한다. (기본값 = 1.6)
user-scalable : yes 또는 no 값을 가지며 사용자가 화면을 확대/축소 할 수 있는지는 지정한다. (기본값 = yes)

<h3>미디어 쿼리 (Media Query)</h3>

<h4>1. CSS 파일 안에서 적용할 때</h4>
.title { // .title에 font-size를 100px로 적용
    font-size: 100px;
}

@media (max-width: 600px) { // 600px보다 작은 화면에서는 font-size를 50px 적용 
  .title {
          font-size: 50px;
    }
}

@media (min-width: 1000px) { // 1000px보다 큰 화면에서는 font-size를 200px 적용 
  .title {
          font-size: 200px;
    }
}

<h4>2. <link> 태그에서 적용할 때</h4>
<link rel="stylesheet" media="(max-width:600px)" href="main.css" > // main.css를 600보다 작은화면에 적용

<h3>block element</h3>
<h4>특징</h4>
<ul>
    <li>블록요소는 vertical-align이 적용되지 않는다.</li>
    <li>블록요소는 text-align이 적용되지 않는다.</li>
</ul>

<h4>HTML 5 블록요소의 종류</h4>

<h3>inline element</h3>
<h4>특징</h4>

<ul>
    <li>인라인요소는 height가 적용되지 않는다</li>
    <li>인라인요소는 width가 적용되지 않는다.</li>
</ul>

<h4>HTML5의 인라인 요소 종류</h4>


<h3>css로 table을 꾸미는 6가지 방법</h3>
<h4>1. 테두리</h4>
<p>border 속성은 기본적으로 상속되지 않습니다. 따라서 table, tr, th td 중 어디에 테두리를 만들지 전략을 짜고 각 태그에 테두리를 달리 적용한다.
    그리고 table 태그에 border-collapse: collapse 속성 값이 있어야 tr, th 태그의 border속성 디자인이 제대로 적용되기 때문에 tr, th 태그에 border 속성이
    있다면 필수적으로 넣어야 한다.html5에서는 유일하게 a태그안에 블록요소가 들어가면 a태그는 자동으로 블록요소가 됩니다.
</p>

<h4>2. 배경색</h4>
<p>교차로 색상을 바뀌게 만들어 주고 싶으면 홀수 행과 짝수 행을 각각 따로 선택하는 가상선택자를 사용하면 됩니다. 
    tr 태그에 tr:nth-child(odd)와 tr:nth-child(even)가상 선택자를 추가하여 서로 다른 color값을 넣어주면 각 행의 색을 교대로
    다르게 만들어 줍니다.
</p>

<h4>3. 마우스 커서가 셀 위에 올라가 있을 때 셀의 색상이나 커서의 모양을 바꾸기</h4>
<p>:hover 가상 선택자를 추가해주면 됩니다. 마우스 오버 상태에서의 color가 기존의 table의 background-color와 시각적으로 어울리게끔 만들어줘 합니다. 마우스 
    커서의 모양을 바꾸는 것은 cursor속성을 사용하면 됩니다.
</p>

tr:hover {
    background-color: #ffc452;
    cursor: pointer;
}

<h4>폰트 크기 조절 및 테두리와 텍스트간의 간격 조절</h4>
<p>font-size를 조절을 해주고 padding을 td selector에 추가하여 여백의 미를 만들어 준다. (레이아웃 깨지지 않게 조심)</p>


<h4>5. 테두리 둥글게 만들기</h4>
<p>표의 겉 테두리를 둥글게 만들어주기 위해서 table태그를 div태그로 감쌉니다. table태그에 직접 둥근 테두리를 적용시키는 것은 매우 번거롭습니다.
    여기에 box-shadow 속성까지 더해주어 좀더 선명한 테두리르 만들어 줍니다.
</p>
div {
    border: 1px solid #000;
    background-color: #000;
    border-radius: 16px;
    bax-shadow: inset 0 0 8px #deb13a;
    width: 160px; height: 160px;
}

<h4>그립자 넣기</h4>
<p>위에서 한 것처럼 box-shadow 속성을 사용합니다 inset을 사용해서 셀 안쪽에 그림자를 만들어도 되고, default 설정인 셀 바깥쪽에 그림자를 만들어도 된다.</p>

<h3>splice</h3>
<p></p>